要明白的是：当前的文件夹是服务器可以检索网页文件的文件夹，在别的文件夹下的html文件虽然也可以被IE打开但是当我想要在别的地方试图通过双击一个文件来打开，带有php脚本的文件的话，结果是我根本不可能打开那样的文件。因为php脚本文件是被apache进行的解析，解析后生成的html文件传给了IE有它进行显示，也就是说浏览器是于apache服务器打交道，而apache服务器是通过脚本语言编写的代码同mysql服务器打交道的。

php.ini里的学问很大，刚才试了一下包含文件的功能，谁知道总是提示不能从c下php目录中的pear文件夹中找到文件，我就猜想也许是php.ini默认指定的搜索头文件路径，所以我将php,ini打开，改到了d盘下，这样问题就解决了，不过我该的时候，还撞到了另一个包含路径指定，好像那个指定是用于安全模式下的，我记得起先下载php安装包的时候，就是下载了一个非安全的，结果不能用，这个是安全版本的，不过照现在来看，应该当前是运行在非安全模式下的。

包含了javascript文件，使用当中定义的函数时，总是提示未定义的函数，查错方式，1，看使用函数的名字是否对了，2，看包含文件名是否对了，3，传入参数是否对了。

activexobject函数在使用时，一定要有参数，当然了随着ie的不断更新参数也在变化，但无论如何没有参数的话，xmlhttprequest对象创建出来就有问题，一般当你觉得自己哪里都没错误但是页面没有反应时，就赶快检查这里，是不是没带参数。

犯了一个天大的错误，我的习惯是将一个实例不断扩展成新的实例，也就是说，后面的实例源码完全是拷贝过来的，我将新的功能实现到新的脚本时，很奇怪总是老功能被调用，唉，真可怕，因为我包含的脚本文件名没有更改，难怪总是老的功能。

java脚本下载图像的实质是，下载.txt中的图像文件名，之后添加<img>标签插回html中

今天遇到的问题是：调用了一个java脚本函数，return值是无效的，因为我return的是responseText的值，我以为临时对象不被保存，可是当我另外声明了一个对象，甚至使用了全局对象时来实现返回时，还是失败，我猜可能是我调用的函数是外部文件中的，我就将该函数移到了当前文件中，喜剧的时，仍然失败，这个问题留下以后解决。原因已经查清楚，因为我引用的那个所谓的外部函数是个异步函数，函数进行下载设置后立即返回，他并不保证下载数据是否已经完成，所以我调用了它后立即想要取回数据是有问题的。

外部java脚本文件中声明的全局变量，在本地文件中第一次使用时，为其初始化值，即使你调用的外部文件函数中对其进行了赋值，也只有当第二次调用该函数后，本地文件中才使用其被赋予的值。怪事，与c语言明显有所不同，这个错误好像是上面的那个引起的，至于全局变量的使用和c语言是没有区别的。
上面这两个问题把我难道了，我本来想自己建一个xmlhttprequest的通用版本，这样省得以后每次要请求数据时重写一次xmlhttprequest对象的建立和配置过程，谁想的到，不仅返回值没有指望，就连外部文件中的全局变量也没有指望，只希望以后的高手帮助来解决了，
我似乎醒悟到一些东西，包含xmlhttprequest对象的函数调用与常规意义上的函数调用是有区别的，这个函数调用后就返回了，只是在调用过程中设置了一个回调函数，也就是说当这个函数返回时，你请求的数据不一定已经到达，所以在这个函数中进行return是没有意义的，毕竟我想要的是下载完的数据，那是不是意味着我可以在回调函数中return呢，也不行因为回调函数并不返回到程序中而是返回到xmlhttprequest对象，至此已目前的只是来看，唯一的解决方案就是不设返回值，而是使用一个全局变量，为了保险的话，在使用时，进行readystate和status判断
今天第一次受到浏览器缓存的坏处，我要加载一张图片，所以先访问一个.txt文件取回图片的文件名，但是有趣的事情是，当我更改了.txt文件中的图片文件名时，浏览器取回的还是之前的文件名，但现在的问题是，我取回文件名后，却不能加载该图片，总提示找不到该文件，又学会了一招，当出错时，可以查看apache的出错日志文档，里面有出错的原因，终于找到原因了，我再将文件名和img标签连接起来时，结尾时用了/，这个关闭标签的记号，但我忽视了文件名和这个东西之间要有一个空格，否则/也被当成了文件名的一部分，也就是说我的文件名无缘无故变成了目录名了，好可怕的事情，幸亏是apache日志文件帮了我，因为在那里显示的图像路径最后有/，这么久的时间终于搞定了，不过我想要写一个通用xmlhttprequest对象的想法还是没有实现，以后再说吧。

java脚本包含文件必须位于当前项目文件夹之下，否则包含的文件并不能被使用
还有就是使用类似图片这类的资源时，资源的地址从项目文件夹开始，比如说我现在使用的项目文件夹时xiao，那我若在当前文件夹中放进图片的话，使用时的地址直接为图片文件名及可，除非我使用的图片文件放在了项目文件夹的子目录中时，才会使用目录径
有以上两点可以得出的结论是：假如我现在要建一个网站，那我的目录规划是这样的，一个主目录作为项目目录，同时也就是网站的主文件夹，在该文件夹下，我可以建html文件夹，js文件夹，以及资源文件夹，等到发布时我将这个主文件夹，放到服务器的某个hdocs下，就ok了。

经过验证发现，当用ie打开一个内含错误dtd内容的xml文档时，ie一直处于加载状态，也就是说ie进行了文档有效性验证，而用别的浏览器时顺利打开，可惜的是ie虽然提供了有效性的验证，但似乎并没有指出错误处在哪里，当然对于普通用户来说他们不关心哪里错了，但程序员需要知道呀，再者说，这种有效性验证据说很费时间，也只有开发人员才会用得到吧，微软呀，微软，你为何不多为程序想一想，你抛弃了程序员，结果就是客户抛弃了你，你忘记了是谁捧红了你。

我渐渐悟出了一些多线程编程的思想，多线程编程最主要的问题就是同步问题，也就是说一个线程的执行可能会依赖于另一个线程处理后的数据，就拿我用浏览器请求数据来说，xmlhttprequest对象负责下载数据，另一个函数负责将下载后的数据进行特定的处理，在这里显然在没有下载完成前，后一个函数的执行是错误的，在这里要么，由前者在下载完成后通知后者让其执行，或者前者仅仅是设置了一个下载完成的标志变量以供后者自己检下载是否完成，前者的弊端在于，如果负责下载的对象实先不知道下载完成后要通知谁的话，该怎么办，尤其当我打算写一个通用下载对象时，面对他的将是各种的数据处理对象，当然如果你只是用来通知特定的数据处理对象的话，这个方法可行，但我想写一个通用下载函数，所以我采用的策略就是，在下载对象中间隔查询下载是否完成，若完成就置标志变量为真，这样的话，对于下载对象来说，他面对的不是各种数据处理对象而是标志变量，接下来要做的就是，数据处理对象定是检测标志变量是否为真，若为真就开始处理数据，否则将数据处理操作放在一个定时函数中，由定时函数间隔询问下载情况，这其实就隐含了一种数据处理函数的逻辑过程，此外我还发现了另一种方法，直接设置定时函数进行定时询问，询问的逻辑为，若下载完成执行处理过程，这样看似简单，却存在严重隐患，你想想下载完成后，标志被置真，每次询问都是真，导致数据处理操作会执行多次，也许对某些问题影响不是很大，但某些问题中重复处理数据一定会带来意想不到的灾难，也许你会说，把下载标志变量置假不就解决问题了，确实这样可以就绝问题，但有可能会带来新的问题，标志变量是下载对象的，本应由下载对象自己来维护，外部的更改会给下载对象带来意想不到的后果，这也许就是c++的思想吧，限制外部对象修改对象内的变量，我的解决方案是，数据处理函数内提供一个进入标志变量，如果下载完成就进入数据处理逻辑部分，同时入口标志置真，这样就避免了处理逻辑重入的的危险。

使用标签名提取xml元素时，即使仅有一个元素也要当成数组[0]处理，显然对于ie与非ie，前者无视xml的空格，后者将空格也当成元素，最好的方法是使用标签处理，即使编写一个去处空格的程序段，也是标签要好，因为无需事先了解文档结构

至此已经学了这几种获取元素的方法，getNamedItem(name);getElementById();getElementsByName();getElementsByTagName();

关于ie和firefox的一些怪异，可以这样讲，他们在很多方面的处理逻辑都是不同的比如说，xml的良构性上，ie上访问的xml不是良构的话，ie的处理措施是，直接将xml的内容都打印出来了，而fox则会提示你哪里的标签不匹配，当xml文档是良构但是与dtd不相符时，ie的措施是，无任何的内容呈现，因为它进行了有效性检查，xml被他认定为无效文档不予以显示，fox呢，依然会显示，fox并不开启有效性检查，不对文档有效性负有任何的责任，从上两点可以看出ie是专注于商业和安全的，fox偏向于开发和高速。

创建xmlhttprequest对象时，1，window.xmlHttpRequest和2，ActiveXObject两个ie都支持，而非ie只支持window.xmlhttprequest，所以判断是否ie时，将1的判断放在2的前面，且必须这样做，否则会将ie当成非ie，因此不要打算在判断window.xmlhttprequest中放入一些打算只让非ie处理的代码，因为ie毕竟也会进入。我的假设可能出错了，我的ie不知是何故它并不用ActiveXObject来通信，原因在调查中。
经过调查，发现ie对两个都支持，如果采用if1-else-if2的判断形式，显然ie总是使用1对象，fox只支持1对象，所以这样难以区分两者，若采用的是if1；if2；的形式，ie会被进入两次，这样实现了，浏览器的区分，当然我的承认这种区分方式有些迂回，如果采用直接检测navigtor这个东西，也许会好一些
事实证明我现在就要修改我的xmlhttprequestobject了，有两个原因，一就是上面提到的if1；if2；形式，最大的缺陷是fox之类浏览器会进入if2，也就是说他们会判断ActiveXObject是否存在，当然对于他们来讲这个东西是未定义的，这样去判断一个未定义的东西不免滑稽，不像php中有个isset函数查看未定义的东西，解决之道终究还是落在了navigator对象上，看来我要开始修改了，另一个问题是，我设置的下载超时判断好像不太严密，我在反复请求下载数据时好像，给了我一个超时警告，而事实是我没有超时，看来得下功夫改改xmlhttprequestobject文件了。

cookie可以提供页面权限验证的功能，假设你没有进入登陆页面的话，后续页面你就不能够访问，但这里有个问题，假如我已经登录页面，也就是说现在我有了cookie设置，这时我直接就可以访问后续页面，而不必通过登录页面访问，但我的登录页面如果url传送变量的话，我直接的访问就可以篡改这个变量，解决方案是，不要再登陆页面传送什么变量，仅仅赋予权限即可，这样才能保证数据不被人修改，即使通过别的较隐蔽的手段传送变量也最好不要这么做，这样会导致，绕过登陆页面的人看到的东西变少，毕竟他已经访问过登陆页面，那你就不该让他看到的东西比别人的少。

今天犯傻了一回，我居然打算不用服务器，直接用ie打开含有php代码的html文件，我在电脑上直接点击打开html文件，我就奇怪了，为何每次都是把我的php源码抛出来了，一开始我以为自己的php代码写的有问题，不断检查，后来我以为我的路径含有非法字符，也没有，最后终于顿悟，php代码与用户而言是不可见的，不可见的意思就是，服务器已经将php代码进行了解析转化为可见的html代码，而我绕过服务器访问php脚本，ie只能够把这些东西理解为普通文本，所以我的php代码被全部抛出，下次遇到php代码写到了ie上，原因有绕过服务器直接访问php，或者apache没有打开

书写语法：ActiveXObject("Microsoft.XMLHTTP")
	window.XMLHttpRequest
	xmlHttpRequestObject.onreadystatechange
	千万要注意大小写和active的参数，网页没反应时，一般都是由于这些导致


不要愚蠢到要在你的电脑上打开一个含有中文路径的文件，不管你是绕过服务器还是通过服务器，那样做的后果是，你除了在地址栏中看到一些百分号和字母外没有别的东西，所以你要因此而被绊倒的话，你就去做在哪里困惑吧，因为你该为你的愚蠢付出一些代价

上次使用鼠标拖动一个div定义的元素时，我就不理解为何要指定，style的position为absulate，今天碰壁了，我定义了两个div元素，而且我在css中指定了他们的位置，可是当我打开页面时发现，他们根本没有按我要求的待在合适的位置，对的，他们换行了，而我想要他们待在一行上，也许是div的问题这是我的第一反应，所以我改成了span，但是依然无效，我在css中随便改动，对页面没有丝毫的影响，我忽然顿悟，div和span都是用来排版页面样式的，他们的作用默认情况下比css要高，当然css也是排版用的，当要指定，css的优先级高于div等元素的方法就是，将position置为abosulate

body元素的onclick属性firefox居然不支持，chorm和ie支持，只是我使用那个检测浏览器信息的navigator实例时发现的，但是我记得之前fox也用过onclick的，我也不清楚是何原因，待查证。

浏览器浏览页面的过程是这样的，发送url向dns服务器请求ip，获得ip地址后，向网站目录请求页面，页面也混杂着脚本的内容发回浏览器，浏览器载入页面，将其中的脚本解析为html元素，响应高优先级的事件，例如onload事件，对页面更新，之后显示页面到浏览器窗口，等待响应别的事件，然后向服务器发送新的请求，并动态更新页面。

onload事件是在页面加载完成后才触发的显然定义一个含有defer的script段一样
document.write下载body中和外部事件响应函数中是不一样的，body中的意味着在页面加载时，也就是页面未关闭时，执行的，而函数中则是当页面关闭时执行，会重写整个页面（之前的内容刷新不可恢复），其实就一个标准，执行document.write时，页面关闭没有？
ajax就是要实现动态更新页面，也就是说上面写在body中的document.write根本不算是动态更新，动态是要在加载完页面后响应事件，向页面写入新的内容的，若用document.write会导致页面的重写，这也许就是早期网页的浏览方式，只要有事件发生就要重写整个页面，而ajax这所以被称为是动态的原因，就在于它提供了新的方法，innerHTML, outerHTML,innerText,outerText, 这是文档元素的属性，text只有ie支持，outer和inner的区别在于，前者可以重写包括元素标签在内的内容，而后者仅仅可以重写标签之间的内容，html的长处在于你插入的不仅仅可以是文本，也可以是img标签，那就是说，他可以更新想要更新的一切html元素，什么图片，声音，视频，很是强大，除了提供了这里的元素属性外，还有别的几个元素方法（函数）可供使用，
insertAdjacentText和insertAdjacentHTML，这两个函数的提供了在当前元素周遭插入内容的方法，参数有两个，1，''beforebegin'',''afterbegin'',''beforeend'',''afterend''
2,要插入的内容，记得加引号封起来。
除了上面的方式外，ie还有一种更新页面的方式，textrange对象，textrange=document.body.createTextRange();创建一个对象，将想要插入内容的元素作下面的处理，textrange.moveToElementText(target);插入内容textrange.pasteHTML('<p>jkdl</p>');很好完成了，上面的几种方式已经足够应对我可能面对的各种问题了，但也许浏览器还提供了什么别的更好的方法，所以我的写下：未完待续。

ie提供的html标签<marquee>,该死的课本又误导我，我刚刚试过了，fox也支持这个标签，它真是强大，一个标签就解决了，文本在窗口中水平的滚动问题，妙用。

我的经验都是来自于教训的，也许别人也是吧，但是像我这种，不服从权威的人，可能会有更多的经验来自教训，今天不知为何，想到要在引用外部javascript的script标签中定义当前页面要用的脚本函数，可是fox说我使用的函数是未定义的，奇了怪了，我明明就定义在这里，为何他却不能是别，找到原因后以后就不大可能犯了。

运用这个东西和marquee标签有的一拼
text = text.substring(1, text.length) + text.substring(0, 1);，要注意的是substring()函数的下标是：开始，最后一个的下一个document.getElementById('here').innerHTML = text;唯一同marquee的区别是，后者飘过全部内容再显示新内容，前者直接是完全的滚动式，没有空白期。

window.settimeout这个函数是超时函数，即超过指定时间后执行指定的代码段，我之前一直以为这东西是间隔一定时间就执行一次指定代码段的，看来错的太深了，要想带到间隔一定时间执行某代码段一次，就需要在settimeout中递归调用函数自己，但是我又遇到了一个问题，浏览器说我的递归调用次数太多了，可是在滚动字符的那个里面，我递归调用的次数也不少呀，为何没提示出错，不能递归，我就又想到了一个好办法，循环javascript中提供的while和for都没问题，我设置一个时间的上限，和时间间隔，每个间隔时间问询一次downloadok，这样就解决了请求数据线程的循环检测downloadok的问题，同时设置的时间上限有助于超时检测，暂定超时处理是，警告，时间间隔和时间上限都可以在xmlhttprequest中设置，
上面的想法再一次宣告破产，while这个东西很快的设置了几个settimeout，根本没有什么超时检测的作用，有没有什么机制，允许一个操作完成再继续循环，真是困惑，
经过我的不懈努力，困惑几乎扫清，现在要我来对一小时前的自己指导一下吧，首先是有清除settimeout的机制的window.cleartimeout,该函数要求一个参数计时器的id，也就是window.settimeout返回的参数，其次确实存在间隔查询的计时函数window.setinterval，可喜的是这个家伙也有对应的kill，即window.clearinterval函数，同样它的参数也是计时器的id，还有就是前面提到的为何我使用settimeout来模拟间隔计时的时候，浏览器提示递归调用太多，问题的根本原因可能是，我的settimeout要执行的代码段是一个含参数的函数，而似乎计时器由于某些我现在还不能搞明白的原因是不允许有参数传入的，解决这个问题的方法是，将参数全局化，或者放在母函数中，这样的话，代码段也可以访问母函数的变量，当然既然人家提供了你setinterval这个利器，你为何不使用。

又得一教训，<img>中img与<之间不能有空格，否则将img视为普通的文本
也许所有的标签都是如此，前面不能有空格


注意了，css中，和js中的东西不比添加引号，但是当放到html中时就要添加引号了

虽说php是服务端的代码但是并不意味着，他不可用在客户端，想html中对url，session，cookie的设置，都在客户端用到php的功能
 
例举一下javascript和php的语法不同点，url中有空格时，php使用urlencode函数，而javascript使用的是+填补空格，其实没有空格也可以（当然urlencode含有额外的功能），javascript中变量与字符串相连使用+，而php中"hell".$num."hell"方式

在“”中使用php的变量时语法为"".$num.""   但是heredoc中可以直接使用变量，千万记得，即便用在heredoc中的引号中的变量也不必使用语法"".$num.""  ，直接使用即可。

吸取教训，1，尽快找一个好的php编辑器，我写的程序没有格式检查功能，很大的php文件有可能就是因为少了一个<"{之类的让我苦恼好久，2，我以前的习惯是，随着项目的不断扩展，我扩展后的项目文件起的名字就是，扩展后的功能加上之前的文件名，这有很严重的问题，当我的项目越来越大时，我自己也搞不清楚文件名的意义了，以后的做法是，文件名以主要的功能来命名，而随着项目的扩展，我要做的创建新的文件夹，这些文件夹的命名使用数字012345或者是当前的时间，如果能够的话，我再写一个项目跟进文件，用来记录我的项目文件夹所对应的功能实现。

不要使用一切关键字在javascript中，我今天的问题是，我的一个input失去焦点时调用函数blur这个函数名和onblur关键字很像，结果我总是不能调用这个函数，至于原因我还是不知道，但是教训就是，以后其的函数名字，要避开关键字

我希望自己再也不要被自己的愚蠢打到，php能直接用浏览器浏览吗，难道你不知道apache是干什的，javascript是浏览器内部实现的所以含有javascript的代码能用浏览器很正常，可是php不是浏览器内置的

设置css是，style添加在html中可以，也可以引用外部文件的css，另外还可以在title中定义style段，注意的是定义依据元素标签名的格式，例：div{，，，}，定义依据元素id属性上格式，例：#idname{，，，}，定义依据class属性的格式，例：.classname{,,}。
注意前面的#和.符号不可少，超链接a:link 未访问时a:visited已访问a:active正访问的css状态定义。

