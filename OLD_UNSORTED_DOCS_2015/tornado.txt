Overview
1. Tornado web application framework:
	application maps *URLs* or *URL patterns* to subclasses of *tornado.web.RequestHandler*,
	those classes define get() or post() methods to *handle HTTP GET or POST requests* to
	that URL
	1. every request URL or URL pattern is mapped to a Handler
		URL or URL pattern can using oridinary string or regualer expression
		a Handler can have several method to handle the requests
	2. URL pattern's groups can be throw to the Handler's method
	3. Handler methods' arguments
		first argument is Request object
			Request object's attributes:
			arguments => all of the requests arguments
			files => upload file
			path => url path
			headers => request heanders
		the following arguments are URL pattern groups
	4. access http arguments
		url pattern groups throw to Handler's method
		Handler.get_arguments(arg_name)
	5. access upload file
		temp = Handler.request.files[input_name] is a list
		temp is a dict{"filename":..., "content_type":..., "body":...}
	6. error response
		in the Handler's method, you can:
			raise tornado.web.HTTPError(403)
	example:
		import tornado.web
		import tornado.ioloop
		class MainHandler(tornado.web.RequestHandler):
			def get(self):
				self.write('You request the main page.')
				# self.arguments => all of the GET and POST arguments
				# self.files => all of the uploaded files(via multipart/form-data POST)
				# self.path => the request path(everything before '?')
				# self.headers => the request headers

		class StoryHandler(tornado.web.RequestHandler):
			def get(self, story_id):
				self.write('You requested the story ' + story_id)

		class MyFormHandler(tornado.web.RequestHandler):
			def get(self):
				self.write('<html><head><title>my-form</title></head>'
							'<body><form action="/myform" method="post">'
							'<input type="text" name="message" />'
							'<input type="file" name="myfile" />'
							'<input type="submit" name="submit" value="Submit"/>'
							'</form></body></html>')
			def post(self):
				# you can set http header
				self.set_header('Content-Type', 'text/plain')
				# self.get_arguments(name) get http arguments
				self.write('You wrote ' + self.get_arguments("message"))
				# access upload file, self.request.files
				# which maps names to a list of files, each file is a dictionary of the
				# form {"filename":..., "content_type":..., "body":...}
				self.write('You upload filename: ' + self.request.files['myfile']['filename'])
		class My404Handler(tornado.web.RequestHandler):
			def get(self):
				# an error response to the client
				raise tornado.web.HTTPError(404)

		application = tornado.web.Application([
		(r'/', MainHandler),
		(r'/story/([0-9]+)', StoryHandler), # Regualer expression groups are passed as 
		# arguments to the RequestHandler methods
		(r'/myform', MyFormHandler),
		(r'/404, My404Handler)
		])

		if __name__ == "__main__":
			application.listen(8888)
			tornado.ioloop.IOLoop.instance().start()
2. When request, the following sequence of calls takes place:
	1. A new RequestHanlder object is created on each request
	2. initialize() is called with keyword arguments from the Application configuration.
		initialize() should typically just *save the arguments passed into member variables*
		; it may not produce any output or call methods like send_error()
	3. perpare() is called. This is most useful in a *base class shared* by all of your 
		handler subclasses, as perpare() is called no matter which HTTP method is used.
		perpare() may produce output; if it calls finish()(or send_error(), etc), processing
		stops here
	4. One of the HTTP methods is called: get(), post(), put(), etc. If the URL regular
		expression contains capturing groups, they are passed as arguments to this method
	5. When the request is finished, on_finish() is called. For synchronous handlers this
		is immediately after get()(etc) return; for asynchronous handlers it is after the
		call to finish()
3. Overriding RequestHandler methods:
	# put into Application keyword configuration
	initialize(self, other_arguments)
	# outputs HTML for use on error pages
	write_error(self, status_code, exc_info=None, **kwargs)
	# see user authentication below
	get_current_user(self)
	# returns login url to be used by the @authenticated decorator
	# (default is in Application settings)
	get_login_url(self)
	# returns location of template files(default is in Application settings)
	get_template_path(self)
	# may be used to set additional headers on the response(such as a custom Server header)
	set_default_headers(self)
	# oridinary response method
	get, post, put, delete, etc.
4. Error handling
	there are three ways to return an error from a RequestHandler:
	1. Manually call set_status() and output the response body normally
	2. Call send_error(). This discards any pending unflushed output and calls
		write_error() to generate an error page
	3. Raise an exception. tornado.web.HTTPError can be used to genrate a specified status
		code; all other exceptions return a 500 status. The exception handler uses 
		send_error() and write_error() to generate the error page
	custom error page:
	the default error page includes a stack trace in debug mode and a one-line description
	of the error(e.g. "500: Internal Server Error"). To produce a custom error page,
	override RequestHandler.write_error(self, status_code, exc_info=None, **kwargs), this
	method may produce output normally via methods such as write() and render(), if the
	error was caused by an exception, an exc_info triple will be passed as a keyword 
	argument
5. Redirection
	There are two main ways to redirect requests:
	1. self.redirect
		using self.redirect() within a RequestHandler method(like get()) to redirect users
		elsewhere.
		the optional argument permanent be used to indicate that the redirection is 
		considered permanent, this triggers a 301 Moved Permanently HTTP status, which is
		useful for e.g redirection to a canonical URl for a page in an SEO-friendly manner
		default the argument permanent is False, which is apt for things like redirecting
		users on *successful POST requests*
		self.redirect('/som-canonical-page', permanent=True)
	2. tornado.web.RedirectHandler
		using RedirectHandler when request URL matched
		example:
			# default RedirectHandler is permanent
			application = tornado.wsgi.WSGIApplication([
				(r"/([a-z]*)", ContentHandler),
				(r"/static/tornado-0.2.tar.gz", tornado.web.RedirectHandler,
					dict(url="https://github.com/tornado")),
			], **settings)
			# turn off the permanent redirection
			application = tornado.wsgi.WSGIApplication([
				(r"/foo", tornado.web.RedirectHandler, {"url":"/bar", "permanent":False}),
			])
6. Templates
	You can use any template language supported by Python, but tornado ships with its
	own templating language, it is faster and more flexible than others
	control statements: 
		syntax: {% statements %} something { % end %}
				statements can be if, for, while, try
	expression:	
		syntax: {{ expression }}
				expression can be any Python expression, including function calls.
	template namespace include the following stuff:
		escape: alias for tornado.escape.xhtml_escape
		xhtml_escape: alias for tornado.escape.xhtml_escape
		url_escape: alias for tornado.escape.url_escape
		json_encode: alias for tornado.escape.json_encode
		squeeze: alias for tornado.escape.squeeze
		linkify: alias for tornado.escape.linkify
		datetime: the Python datetime module
		handler: the current RequestHandler object
		request: alias for handler.request
		current_user: alias for handler.current_user
		locale: alias for handler.locale
		_: alias for handler.locale.translate
		static_url: alias for handler.static_url
		xsrf_form_html: alias for handler.xsrf_form_html
		reverse_url: alias for Application.reverse_url
		All entries from the ui_methods and ui_modules Application settings
		Any keyword arguments passed to render() or render_string()
	template inheritance:
		supports *extends* and *block* statements(like django)
	notice:
		1. turn off autoescape
		All template output is escaped by default, using the tornado.escape.xhtml_escape
		function. This behavior can be changed *globally* by passing autoescape=None to the
		Application or TemplateLoader constructors, for *a template file* with the {% 
		autoescape None %} directive, or *a single expression* by replacing {{ ... }} with
		{{ raw ... }}
7. Cookies
	self.set_cookie(name, value)
	self.get_cookie(name)
	self.set_secure_cookie(name, value)
	self.get_secure_cookie(name)
	example:
		class MainHandler(tornado.web.RequestHandler):
			def get(self):
				if not self.get_cookie("mycookiename"):
					self.set_cookie("mycookiename", "cookievalue")
					self.write("You first time come here!")
				else:
					self.write("You came here once again.")
	example1:
		# set secure cookie to prevent forge cookie
		# by additional timestamp and signature to prevent forge
		class MainHandler(tornado.web.RequestHandler):
			def get(self):
				if not self.get_secure_cookie('mycookie'):
					self.set_secure_cookie('mycookie', 'myvalue')
					self.write('You never came here before.')
				else:
					self.write('You had came here.')
		# you need to specify a secert key named *cookie_secert* when you create
		# your application
		application = tornado.web.Application([
			(r"/", MainHandler),
		], cookie_secert="__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__")
8. User authentication
	Access authenticated user:
		in request handler by self.current_user(default is None)
		in template by current_user(default is None)
	To implement user authentication in your application, you need to override the
		get_current_user() method in your every request handler
	If the request authentication, you can test self.current_self, or you can use more
	easire way, Python decorator *tornado.web.authenticated* and settings *login_url*
	example:
		import tornado.web
		class BaseHandler(tornado.web.RequestHandler):
			def get_current_userr(self):
				return self.get_secure_cookie('username')
		class MainHandler(BaseHanlder):
			def get(self):
				if not self.current_user:
					self.redirect('/login')
					return
				name = tornado.escape.xhtml_escape(self.current_user)
				self.write('Hello! ' + name)
		class LoginHandler(BaseHandler):
			def get(self):
				self.write('<html><body><form action="/login" method="post">'
						   'Name: <input type="text" name="username" />'
						   '<input type="submit" value="Submit"/>'
						   '</form></body></html>')
			def post(self):
				self.set_secure_cookie('username', self.get_argument('username'))
				self.redirect('/')
	example1:
		class MainHandler(self):
			@tornado.web.authenticated 
			# auto test self.current_user
			# if is None, redirect to login_url
			def get(self):
				username = tornado.escape.xhtml_escape('username')
				self.write('Hello ' + username)
		settings = {
			"cookie_secret": "__TODO:_GENEREATE_YOUR_OWN_RANDOM_VALUE_HERE__",
			"login_url": "/login"
		}
		application = tornado.web.Application([
			(r'/', MainHandler),
			(r'/login', LoginHandler),
		], **settings)
9. Cross-site request forgery(XSRF)
		solution: cookie every user with an unpredictable value and include that value
			as an additional argument with every form submission on your site, if the
			cookie and the value in the form submission do not match, indicate the request
			is forged
		tornado solution:
			settings = {
				"cookie_secret": "__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__",
				"login_url": "/login",
				"xsrf_cookies": True,
			}
			application = tornado.web.Application([
				(r"/", MainHandler),
				(r"/login", LoginHandler),
			], **settings)
			# application will set the _xsrf cookie for all users and reject all POST,
			# PUT, and DELETE requests that do not contain a correct _xsrf value
			NOTICE: 
			1. In template code <form method="post"></form>, you should insert
			{% module xsrf_form_html() %}
			2. Submit by AJAX, you should submit _xsrf value with each request, example:
				jQuery.postJSON = function(url, args, callback) {
					// add _xsrf cookie
					value = document.cookie.match('\\b_xsrf=([^;])\\b')
					value = value[1] ? value[1]:undefined
					args._xsrf = value
					$.ajax({url: url, data: $.param(args), 
					dataType: "text", type: "POST",
					success: function(response){callback(eval('('+response+')')}
					})
				}
			3. For PUT, DELETE requests the XSRF token may also be passed via an HTTP 
				header named X-XSRFToken or X-CSRFToken(the latter is accepted for 
				compatibility with django)
			4. In a pure-javascript application that does not use any regular forms, so you
				can {% module xsrf_form_html() %}, you access self.xsrf_token manually
			5. If you want to customize XSRF behavior on a per-handler basis, you can 
				override RequestHandler.check_xsrf_cookie()
10. Static files and file caching
	You can server static files from Tornado by specifying the static_path setting
	in your appliction:
		settings = {
			# static files directory path
			"static_path": os.path.join(os.path.dirname(__file__), "static"),
			"cookie_secret": "__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__",
			"login_url": "/login",
			"xsrf_cookies": True,
		}
		application = tornado.web.Application([
			(r"/", MainHandler),
			(r"/login", LoginHandler),
			(r"/(apple-touch-icon\.png)", tornado.web.StaticFileHandler,
			dict(path=settings['static_path']))
		], **settings)
		1. you need to specify the static files physically directory by setting 
			static_path
		2. In your html reference url is absolute, which starts with /static/ urls will be 
			auto-process by tornado.web.StaticFileHandler
		3. If your html reference url is relative, which starts from static files 	
			directory sub-directory, in your template code you should static_url(your-
			relative-url)
		4. static_url() can convert relative url to absolute url, and maintain caching 
			files, the converted url like this: /static/images/test.png?v=1e4r5, the v is
			file content hash value, so if the file content is changed, the v is change,
			so broswer reload the file, or use the caching file
		5. manually static file handler, static file url is not start with /static/,
			you can manually handler:
				(r"/(apple-touch-icon\.png)", tornado.web.StaticFileHandler, 
				dict(path=settings['static_path']))
			apple-touch-icon.png file is in the static files directory, regular group
			is neccessary, is passed to Handler
		6. automatically server /robots.txt and /favicon.ico from static directory(
			even though they don't start with the /static/ prefix)
11. Localization
	The locale of the current user:
		In Handler: self.locale
		In template: handler.locale or locale
	The name of locale(e.g., en_US):
		locale.name
	Translate strings:
		locale.translate("This is a string")
		locale.translate("A Person", "Some people", len['wikty', 'mouse'])
		(In template _() is alias for locale.translate())
	1. By default, detect the user's locale using the Accept-Language HTTP request header
		sent by the user's browser, translate page to Accept-Language
	2. If Accept-Language is undfined, locale is en_US
	3. If you let user set their locale as perference, you should override default locale
		selection by overriding get_user_locale() in your request handler:
		class BaseHandler(tornado.web.RequestHandler):
			def get_current_user(self):
				user_id = self.get_secure_cookie("user")
				if not user_id: return None
				return self.backend.get_user_by_id(user_id)
			def get_user_locale(self):
				if "locale" not in self.current_user.prefs:
					# Use default detect locale method
					# by the Accept-Language header
					return None
				# or return the locale name
				return self.current_user.prefs["locale"]
	4. How translate work
		tornado.locale.load_translations(transltaions-dict-dirname)
		the directory contains, e.g. es_GT.cvs or fr_CA.cvs, you typically call this method
		once when your start server
	5. tornado.locale.get_supported_locales()
12. UI modules
	special functional calls to render *components of your page*, and they can come
	packaged with their *own CSS and Javascript*
	How can use it?
		You should add to settings: settings = { "ui-modules": yourmodule}
		In template code reference ui module: {% module YourUIModule() %}
	What is a ui module?
		example:
		class Entry(tornado.web.UIModule):
			def embedded_css(self):
			# add css for your component
				return ".entry { margin-bottom: 1em; }"
			def render(self):
			# render ui module to  a component of your page
				return self.render_string('entry.tmpl', arg_for_entry)
	How to define a ui module?
		as your see, you can override above methods:
		render, embedded_css, embedded_javascript, css_files, javascript_files
		on matter how many times a ui module is used on a page, css and javascript
		will be included once, css always in <head>, javascript before</body>
	Template itself can be a ui module:
		Python code is not required, template support embed css and javascript
		example:
			---------- template as a ui module ----------------------------
			# module-entry.tmpl
			{{ set_resources(embedded_css=".entry { margin-bottom: 1em; }") }}
			<!--other template code-->
			--------- invoke the ui module ---------------------------------
			# entry.tmpl
			{% module Template("module-entry.tmpl")}
13. Maintain a request
	By default tornado automatically finish a request when handler is excuted, 
	if you want to a request open after the main request handler method returns
	using the *tornado.web.asynchronous* *decorator*
	example:
		class MainHandler(tornado.web.RequestHandler):
			@tornado.web.asynchronous
			def get(self):
				self.write('Hello world!')
				# you must call finish() to finish the HTTP request
				# or the user's browser will simply hang on
				self.finish()
14. Asynchronous HTTP Clients
	tornado has two asynchronous non-blocking HTTP client:
		1. SimpleAsyncHTTPClient
			tornado.simple_httpclient.SimpleAsynchronousHTTPClient
			simple client, just depend on tornado.ioloop
		2. CurlAsyncHTTPClient
			tornado.curl_httpclient.CurlAsynchronousHTTPClient
			curl client depend on *libcurl* and *pycurl*
	access asynchronous client:
		tornado.httpclient.AsyncHTTPClient(default is SimpleAsynchronousClient)
	switch asynchronous client:
		tornado.httpclient.AsyncHTTPClient.configure(
			'tornado.curl_httpclient.CurlAsynchronousHTTPClient')
15. Third party authentication
	Tornado's auth module support a number of the most popular sites on the web
	example:
		# using Google authentication
		class GoogleHandler(tornado.web.RequestHandler, tornado.auth.GoogleMixin):
			@tornado.web.asynchronous
			def get(self):
				if self.get_argument("openid.mode", None):
					self.get_authenticated_user(self._on_auth)
					return
				self.authecticat_redirect()
			def _on_auth(self, user):
				if not user:
					self.authenticate_redirect()
					return
				# save the user with, e.g., set_secure_cookies
16. Debug mode and automatic reloading
	Turn on debug mode:
		pass debug=True to the Application contstructor, the app will be run in
		debug/development mode
	debug mode features:
		1. the app will watch for changes to its source files and reload itself when
			anything changes
		2. Templates will not be cached, nor will static file hashes
		3. When an exception in a RequestHandler is not caught, an error page 
			including a stack trace will be generated
	debug mode is not compatible with HTTPServer's multi-process mode:
		you must not give HTTPServer.start an argument other than 1 if you are using
		debug mode
	you can using reload as a standalone module:
		tornado.autoreload is the reload module
		set debug=True, and start your app by: python -m tornado.autoreload myserver.py
		to catch any syntax errors or other errors at startup
	reloading loses any Python interpreter command-line arguments
17. Running Tornado in production
	please look up the manual
18. WSGI and Google AppEngine
	WSGI does not support non-blocking:
	Tornado comes with limited support for WSGI, because WSGI does not support non-blocking
	requests, so if you choose to use WSGI instead of Tornado's HTTP server you cannot use
	any of the asynchronous features
	example:
		import tornado.web
		import tornado.wsgi
		import tornado.wsgiref.handlers

		class MainHandler(tornado.web.RequestHandler):
			def get(self):
				self.write("Hello, world")

		if __name__ == "__main__":
			application = tornado.wsgi.WSGIApplication([
				(r"/", MainHandler),
			])
			wsgiref.handlers.CGIHandler().run(application)


Core Web Framework
1. tornado.web
	tornado.web provides a simple web framework with *asynchronous features* that allow it
	to scale to *large numbers of open connections*, making it ideal for *long polling*
	1. not thread-safe
		methods such as write(), finish(), flush() must only be called from the main
		thread. If you use multiple threads it is important to use IOLoop.add_callback()
		to transfer control back to the main thread before finishing the request
	2. class tornado.web.RequestHandler(application, request, **kwargs)
		1. SUPPORTED_METHODS
			If you want to support more methods than the standard GET/POST/HEAD, you
			should override the class variable SUPPORTED_METHODS in your subclass
		2. initialize(self, args...)
			hook for subclass initialization
			a dict passed as the third arguments of a url spec will be supplied as
			keyword arguments to initialize()
			example:
				class MainHandler(tornado.web.RequestHandler):
					def initialize(self, database)
						self.database = database
				app = tornado.web.Application([
				# third argument pass to handler's initialize
					(r"/", MainHandler, dict(database=database))
				])
		3. prepare()
			override this method to perform common initialization regardless of the
			request method
			asynchronous support: *decorate* this method with *gen.coroutine* or
			*return_future* to make it asynchronous(the decorate *asynchronout cannot
			be used on prepare()). If this method returns a *Future* execution will
			not procee until the Future is done
		4. on_finish()
			called after the response has been sent to the client, override this method
			to perform cleanup, logging, etc.
		5. HTTP methods
			get(*args, **kwargs)
			post(*args, **kwargs)
			put(*args, **kwargs)
			delete(*args, **kwargs)
			head(*args, **kwargs)
			options(*args, **kwargs)
			Notice: these methods can be made asynchronous with one of the following
				decorators: *gen.coroutine*, *return_future*, or *asynchronous*
		6. get_argument(name, default=[], strip=True)
			If name is not existed and default is not provided, will raise exception
			MissingArgumentError
			If name appears in the url more than once, return the last value
			The returned value is always unicode
		7. get_arguments(name, strip=True)
			Returns a list of the arguments with the given name
			If name is not existed, will return empty list
			The returned value is always unicode
		8. decode_argument(value, name=None)
			The argument has been percent-decoded and is now a byte string. By default
			, this method decodes the argument as utf-8 and returns a unicode string
			, but this may be overridden in subclass
		9. request
			The tornado.httpserver.HTTPRequest object containing additional request
			parameters including e.g. headers and body data
		10. path_args
			contain the positional arguments that are passed to the HTTP verb methods
		11. path_kwargs
			contain the keyword arguments that are passe to the HTTP verb methods
		12. set_status(status_code, reason=None)
			status_code => is integter, indicate response code.
			reason => Human-readable reason pharse describing the status code, if is
			None, it will be filled in from httplib.responses
		13. set_header(name, value)
			value => if a datetime is given, we automatically format it according to
			the HTTP specification. If the value is not a string, we convert it to a
			string.
			All header values are then encoded as utf-8
		14. add_header(name, value)
			can be called multiple times to return multiple values for the same header
		15. clear_header(name)
			undoing a previous set_header() call
			does not apply to multi-valued headers set by add_header()
		16. set_default_headers()
			override this to set HTTP headers at the beginning of the request, you can
			custom http header
			when error handling, the set headers is reset
		17. write(chunk)
			wirte chunk to the output buffer(so you can call more than once for one
			response)
			chunk can be string or dictionary, if it is dict, automatically convert to
			JSON to write and set Content-Type=application/json(if you want to send
			json as a different Content-Type, call set_header() after calling write())
		18. flush(include_footers=False, callback=None)
			flushes the current output buffer to the network
			callback => be called when all flushed data has been written to the socket,
				only one flush callback can be outstanding at a time
		19. finish(chunk=None)
			finishe this response, ending the HTTP request
		20. render(template_name, **kwargs)
			renders the template with the given arguments as the response
		22. render_string(template_name, **kwargs)
			generate the given template with given arguments, return the generated byte
			string(utf-8), does not write to network
		23. get_template_namespace()
			return a dict to be used as the default template namespace
		24. redirect(url, permanent=False, status=None)
			status => used as the HTTP response status code, default is 301(permanent)
				or 302(temporary) is chosen based on the permanent argument
		25. send_error(status_code=500, **kwargs)
			If flush() has already been called, it is not possible to send an error,
				so this method will simply terminate the response.
			If output has been written but not yet flushed, it will be discarded and
				replaced with the error page
			Send_error will invoke write_error() to generate error page, the kwargs
				argument will be passed to write_error
		26. write_error(status_code, **kwargs)
			Override to implement custom error page
			May call write, render, set_header, etc to product output as usual
			If this error was caused by an uncaught exception(including HTTPError),
				an exc_info triple will be available as kwargs['exc_info']
			For historical reasons, if a method get_error_html exists, it will be 
				used instead of the default write_error implementation, Note that
				get_error_html will be discarded
		27. clear()
			reset all header and content for this response
		28. cookies
			alias for self.request.cookies
		29. get_cookie(name, default=None)
		30. set_cookie(name, value, domain=None, expires=None, path='/', 
				expires_days=None, **kwargs)
			additional kwargs are set on the Cookie.Morsel directly
		31. clear_cookie(name, path='/', domain=None)
		32. clear_all_cookies()
		33. get_secure_cookie(name, value=None, max_age_days=31)
			the decoded cookie value is returned as a byte string(unlike get_cookie)
		34. set_secure_cookie(name, value, expires_days=30, **kwargs)
			You must specify the cookie_secret in your Application's settings, It
			shold be a long random sequence of bytes to be used as the HMAC secret
			for the signature
			Secure cookies may contain arbitrary byte values, not just unicode 
				strings(unlike regular cookie)
		35. create_signed_value(name, value)
			signs and timestamps a string, if you want to decode the return value:
			value = self.get_secure_cookie(name, return_value)
		36. application
			The Application object serving this request
		37. async_callback(callback, *args, **kwargs)
			will be discarded
		38. check_xsrf_cookie()
			verifies that the _xsrf cookie matches the _xsrf argument(post form field or
			HTTP header X-XSRFToken or HTTP header X-CSRFToken)
		39. compute_etag()
			computes the etag header to be used for this request, by default uses a hash
			of the content written so far, may be overridden to provide custom etag 
			implementations, or may return None to disable tornado's default etag support
		40. create_template_loader(template_path)
			return a new template loader for the given path, may be overridden by subclass
			, by default returns a directory-based loader on the given path, using the
			autoescape application setting, if a template_loader application setting is
			supplied, uses that instead
		41. get_browser_locale(default='en_US')
			return user's locale, based on HTTP request header Accept-Language
		42. get_current_user()
			override to determine the current user from, e.g. a cookie
		43. get_login_url()
			override to customize the login url based on the request
			by default, we use the login_url application setting
		44. get_status()
			return the status code for our response
		45. get_template_path()
			override to customize template path for each handler
			by default, we use the template_path application setting, return None to
			load templates relative to the calling file
		46. get_user_locale()
			overrider to determine the locale from tha authenticated user
			if None is returned, we fall back to get_browser_locale()
			This method should return a tornado.locale.Locale object, most likely obtained
			via a call like tornado.locale.get('en')
		47. log_exception(typ, value, tb)
			override to customize logging of uncaught exceptions
			by default logs instances of HTTPError as warnings without stack traces and
			all other exceptions as errors with stack traces
		48. on_connection_close()
			called in async handlers if the client closed the connection
			override to clean up resources associated with long-lived connections.
			Note that this method is called only if the connection was closed during
			asynchronous processiong; if you need to do clean up after every request
			override on_finish() instead
			Proxies may keep a connection open for a time after the client has gone away,
			so this method may not be called promptly after the end user closes connection
		49. require_setting(name, feature='this feature')
			raise an exception if the given app setting is not defined
		50. reverse_url(name, *args)
			alias for Application.reverse_url
		51. settings
			alias for self.application.settings
		52. static_url(path, include_host=None, **kwargs)
			Return a static URL for the given relative static file path
			This method requires you set the static_path setting in your application(
				which specifies the root directory of your static files)
			This method returns a versioned url(by defalut appending ?v=<sigature>)
				,which allows the static files to be cached indefinitely. 
			You can be disabled versioned url by passing include_version=False
			By defalut this method returns URLs relative to the current host, but if
			include_host is true the URL returned will be absolute.
			If this handler has an include_host attribute, that value will be used as
				the default for all static_url calls that do not pass inclue_host
				as a keyword argument
		53. xsrf_form_html()
			return an html <input/> element to be included with all POST forms
	3. Application(handlers=None, default_host='', transforms=None,wsgi=False, **settings)
		Instances of this class are callable:
			application.listen(3000)
		Instances of this class can be passed directly to HTTPServer:
			import httpserver
			http_server = httpserver.HTTPServer(application)
			http_server.listen(3000)
		Constructor takes in a list of URLSpec objects or tuples:
			1. when receive requests, iterate over the list in order and instantiate an
				instance of the first request class whose regexp matches the request path
			2. each tuple can contain an optional third element, which should be a dict,
				is passed as keyword argument to the constructor of the handler
		Virtual host support:
			application.add_handlers(r"www\.myhost\.com",[
				(r"/", MainHandler),
			])
		Settings:
			1. general settings
				debug: If True the application runs in debug mode
				gzip: If True, responses in textual formats will be gzipped automatically
				log_function: This function will called at the end of every request to
							  log the result(with one argument, the RequestHandler obejct)
							  By defalut implementation writes to the logging module's root
							  logger
				ui_modules:
				ui_methods: May be set to a mapping of UIModule of UI methods to be made
							available to templates. May be set to a module, dictionary,
							or a list of module and/or dicts
			2. Authentication and Security settings
				cookie_secret: Used by handler.get_secure_cookie and 
							   handler.set_secure_cookie as sign cookies
				login_url: The authenticated decorator will redirect to this url if the 
						   user is not logged in
				xsrf_cookies: If True, xsrf will be enabled
				twitter_consumer_key, twitter_consumer_secret, friendfeed_consumer_key,
				friendfeed_consumer_secret, google_consumer_key, google_consumer_secret,
				facebook_api_key, facebook_secret: Used in the tornado.auth module
			3. Template settings
				autoescape: Default "xhtml_escape" to escape template content, set to None
							to disable escaping or the name of a function that all output
							should be passed through
							Can be changed on a per-template basis with {% autoescape %}
				template_path: Directory containing template files
				template_loader: Assign to an instance of tornado.template.BaseLoader to 
								 customize template loader
								 If settings is used the template_path and autoescape, this
								 will be ignored
			4. Static files settings
				static_path: Directory from which static files will be served
				static_url_prefix: url prefix for static files, defaults to '/static/'
				static_handler_class: Set to use a different handler for static files
									  instead of the default tornado.web.StaticFileHandler
				static_handler_args: If set, should be a dict to be passed to the customize
									 static file handler's intialize() method
		Application.listen(port, address='', **kwargs):
			This is a converience alias for creating an HTTPServer object and calling its
			listen method, kwargs are passed to the HTTPServer constructor
			Note that after calling listen you still need to call IOLoop.instance().start()
		Application.add_handlers(host_pattern, host_handlers):
			Appends the given handlers to our handler list
		Application.reverse_url(name, *args):
			Returns a URL path for handler named name
			The handler must be added to the application as a named URLSpec
		Application.log_request(handler):
			Writes a completed HTTP request to the logs
			By default writes to the Python root logger, to change this behavior either
			subcalss Application and override this method, or pass a function in the
			application settings dict as log_function
	4. class tornado.web.URLSpec(pattern, handler_class, kwargs=None, name=None)
		Specifies mappings between URLs and handlers
		pattern: regular expression to be url matched, any groups in the regex will be
				 passed into the handler's get/post/etc method as arguments
		handler_class: RequestHandler subclass
		kwargs(optional): A dict will be passed to handler's constructor
		name(optional): A name for this handler, used by Application.reverse_url
	5. Decorators
		1. tornado.web.asynchronous(method)
			Wrap request handler methods(get/post/put/delete) with this if they are
				asynchronous
			This decorator should only be applied to the HTTP verb methods, it behavior
				is undefined for any other method
			This decorator to be useful the method must do something asynchronous
			Unnecessary using this and @gen.coroutine combine
			If this decorator is given, the response is not finished when the method
				returns, it is up to the request handler to call self.finish() to finish
				the HTTP request, without this decorator, the requst is automatically
				finished when the get() or post() method returns
		2. tornado.web.authenticated(method)
			Decorate methods with this to require that the user be logged in
			If the user is not logged in, they will be redirected to login_url
		3. tornado.web.addslash(method)
			Use this decorator to add a missing trailing slash to the request path
				e.g, a request to /foo would redirect to /foo/ with this decorator
			Your handler mapping regular expression like r'/foo/?'
		4. tornado.web.removeslash(method)
			Use this decorator to remove trailing slashes from the request path
				e.g, a request to /foo/ would redirect to /foo with this decorator
			Your handler mappiing regular expression like r'/foo/*'
	6. Everything Else
		1. exception tornado.web.HTTPError(status_code, log_message=None, *args, **kwargs)
			An exception that will turn into an HTTP error response
		2. exceptioon tornado.web.MissingArgumentError(arg_name)
			Exception raised by RequestHandler.get_argument, this is subclass of HTTPError
				so if it is uncaught a 400 response code will be used instead of 500
		3. class tornado.web.UIModule(handler)
			.render(*args, **kwargs):
				overridden in subclasses to return this module's output
			.embedded_javascript()
				return a javascript string that will be embedded in the page
			.javascript_files()
				returns a list of javascript files required by this module
			.embedded_css()
				returns a css string that will be embedded in the page
			.css_files():
				return a list of css files required by this module
			.html_head():
				return a css string that will be put in the <head></head> html element
			.html_body():
				return an html strin that will be put in the <body></body>
			render_string(path, **kwargs):
				renders a template and return it as a string
		4. class tornado.web.ErrorHandler(application, request, **kwargs)
			generates an error response with status_code for all requests
		5. class tornado.web.FallbackHandler(application, request, **kwargs)
			example:
				wsgi_app = tornado.wsgi.WSGIContainer(
					django.core.handlers.wsgi.WSGIHandler())
				appplication = tornado.web.Application([
					(r"/foo", FooHandler),
					# regex must be .*, and this item must be the last item
					(r".*", FallbackHandler, dict(fallback=wsgi_app))
				])
		6. class tornado.web.RedirectHandler(application, request, **kwargs)
			Redirects the client to the given URL for all *GET requests*
			example:
				application = tornado.web.Application([
					(r"/oldpath", tornado.web.RedirectHandler, dict(url="/newpath")),
				])
		7. class tornado.web.StaticFileHandler(application, request, **kwargs)
			A simple handler that can serve static content from directory
			A StaticFileHandler is configured automatically if you set the static_path
				in settings
			Customize by static_url_prefix, static_handler_args, static_handler_class
				settings
			Manually map path to StaticFileHandler:
				application = tornado.web.Application([
					(r"/content/(.*)", tornado.web.StaticFileHandler, {"path": "/var/www"})
				])
				Notice: regex group is required, third argument path is required
			There are many methods in StaticFileHandler, please look up manual
2. tornado.httpserver
	A non-blocking, single-threaded HTTP server
	A server is defined by a request callback that takes an HTTPRequest object as an
		argument and writes a valid HTTP response with HTTPRequest.write, HTTPRequest
		.finish() finishes the request
	example:
		# A simple example server that echoes back the URI you requested
		import tornado.httpserver
		import tornado.ioloop
		def request_handler(request):
			message = "You requested %s \n" % request.uri
			request.write("HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\n%s" %
				len(message), message)
			request.finish()
		httpserver = tornado.httpserver.HTTPServer(request_handler)
		httpserver.listen(3000)
		tornado.ioloop.IOLoop.instance().start()
	1. class tornado.httpserver.HTTPRequest(method, uri, version='HTTP/1.0', headers=None
											body=None, remote_ip=None, protocol=None,
											host=None, files=None, connection=None)
		Attributes:
			method: HTTP request method, e.g. "GET" or "POST"
			uri: The requested uri
			path: The path portion of uri
			querey: The query portion of uri
			version: HTTP version specified in request, e.g. "HTTP/1.1"
			headers: HTTPHeaders dictionary-like object for request headers. Acts like a
					 case-insensitive dictionary with additional methods for repeated
					 headers
			body: Request body, if presend, as a byte string
			remote_ip: Client's IP address as a string. If HTTPServer.xheaders is set,
					   will pass along the real IP address provided by a load balancer
					   in the X-Forwarded-For header
			protocol: The protocol used, either 'http', or 'https'. If 
					  HTTPServer.xheaders is set, will pass along the protocol used by
					  a load balancer if report via an X-Scheme header
			host: The requested hostname, usually taken from the Host header
			arguments: GET/POST arguments are available in the arguments property, which
					   maps arguments names to lists of values(to support multiple values
					   for individual names), names are of type str, while arguments are
					   byte strings. Note that this is different from RequestHandler.
					   get_argument(), which returns argument values as unicode strings
			files: File uploads are available in the files property, which maps file 
				   names of lists of HTTPFile
			connection: An HTTP request is attached to a single HTTP connection, which
						can be accessed through the "connection" attribute. Since
						connnections are typically kept open in HTTP/1.1, mutliple 
						requests can be handled sequentially on a single connection
			supports_http_1_1(): Returns True if this request supports HTTP/1.1 semantics
			cookies: a dictionary of Cookie.Morsel objects
			write(chunk, callback=None): Writes the given chunk to the response stream
			finish(): Finishes this HTTP request on the open connection
			full_url(): Reconstructs the full URL for this request
			request_time(): Returns the amount time it took for this request to execute
			get_ssl_certificate(binary_form=False): Returns the client's SSL certificate,
													if any.
													To use client certificates, the 
													HTTPServer must have been constructed 
													with cert_reqs set in ssl_options, e.g
													server = HTTPServer(app,
													ssl_options=dict(
														certfile="foo.txt",
														keyfile="foo.key",
														cert_reqs=ssl.CERT_REQUEST,
														ca_certs="cacert.crt"))
	2. class tornado.httpserver.HTTPServer(request_callback, no_keep_alive=False,
									ioloop=None, xheaders=False, ssl_options=None,
									protocol=None, **kwargs)
		HTTPServer parses the request headers and body, request callback produces the
			response, this affords maximum flexibility for applications to implement
			whatever parts of HTTP responses are required
		HTTPServer supports keep-alive connections by default, the request callback
			must response either the Content-Length header or Transfer-Encoding:chunked
			If app is non-keep-alive, should response the Connection: close header and
			pass no_keep_alive=True to the HTTPServe constructor
		If xheaders is True, we support the X-Real-IP/X-Forwarded-For(about remote ip)
			and X-Scheme/X-Forwarded-Proto(about protocol) headers, these headers are
			useful when running Tornado behind a reverse proxy or load balancer
		To make this server serve SSL traffic, send the ssl_options dictionary argument
			with the arguments required for the ssl.wrap_socket method, including certfile
			and keyfile(In Python3.2 you can pass an ssl.SSLContext object instead of dict)
		Initialization:
			1. listen: single-process
				server = tornado.httpserver.HTTPServer(app)
				server.listen(3000)
				tornado.ioloop.IOLoop.instance().start()
				# equal to: app.listen(3000)
			2. bind/start: multiple-process
				server = tornado.httpserver.HTTPServer(app)
				server.bind(3000)
				server.start(0) # Forks multiple sub-processes
				tornado.ioloop.IOLoop.instance().start()
			3. add_sockets: advanced multiple process
				sockets = tornado.netutil.bind_socket(3000)
				tornado.process.fork_processes(0)
				server = tornado.httpserver.HTTPServer(app)
				server.add_sockets(sockets)
				tornado.ioloop.IOLoop.instance().start()
	3. class tornado.httpserver.HTTPConnection(stream, address, request_callback,
											   no_keep_alive=False, xheaders=False,
											   protocol=None)
		we parse HTTP headers and bodies, and execute the request callback until HTTP
		connection is closed
		set_close_callback(): Set a callback that will be run when the connection is closed
		write(chunk, callback=None): Writes a chunk of output to the stream
		finish(): Finishes the request
3. tornado.template
	Overview:
		Template basic usage:
			t = tornado.template.Template("<html>{{ myvalue }}</html>")
			t.generate(myvalue="XXX") => return "<html>XXX</html>"
		Loader usage:
			# loads templates from a root directory and cached the compiled templates
			loader = tornado.template.Loader("/home/wikty/tmpl")
			loader.load("test.html").generate(myvalue='XXX')
		Template extend:
			supports {% block blockname %}{% end %}, {% extends "template.tmpl" %} syntax
		No restrictions on the template expression:
			you can do anything as in your Python code, e.g.
			{% for student in [p for p in people if p.student and p.age >23] %}
		Using function in template:
			pass custom function to template namespace:
				def add(a, b):
					return a+b
				t = tornado.template.Template("{{ add(1, 2) }}")
				t.execute(add=add)
			using built-in template function:
				like: escape(), static_url(), json_encode()
	Syntax Reference:
		{{ expression }}
			expression may be any Python expression, which will be escaped according to
			the current autoescape setting and inserted into the output
			(if you need to include a literal {{, escaped as {{! )
		{% statement %}
			if you need to include a literal {%, escaped as {%!
		{# content #}
			comment out a section
		{% apply function_name %}...{% end %}
			applies a function to the output between apply and end
		{% autoescape function_name %}
			Sets the autoescape mode for the current file. This does not affect other 
			files, even those referenced by {% include %}
			{% autoescape xhtml_escape %}
			{% autoescape None %}
			Note that autoescaping can also be configured globally, at Application or
			Loader
		{% block block_name %}...{% end %}
			Blocks in the parent template will be replaced with the contents of the same-
			named block in a child(extends) template
		{% comment ... %}
			comment content. Note that there is no {% end %}, comment inner content
		{% extends filename %}
			Inherit from anther template
		{% for var in expr %}...{% end %}
			Same as the Python for statement, {% break %} and {% continue %} may be used
			inside the loop
		{% import module %}
		{% from x import y %}
			Same as the Python import statement
		{% if condition %}...{% elif condition %}...{% else %}...{% end %}
		{% include filename %}
			Includes another template file. The included file can see all the local
			variables as if were copied directly to the point of the include directive.
			{% module Template('foo.html') %} has isolated namespace
		{% module expr %}
			Renders a UIModule. The output of the UIModule is not escaped
		{% raw expr %}
			Outputs the result of the given expression without autoescaping
		{% set x = y %}
			Set a locale variable
		{% try %}...{% except %}...{% finally %}...{% else %}...{% end %}
			Same as the Python try-except
		{% while condition %}...{% end %}
			Same as the Python while, {% break %} and {% continue %} may be used
			inside the loop
	Class Reference:
		1. class tornado.temlate.Template(template_string, name="<string>", loader=None,
								compress_whitespace=None, autoescape="xhtml_escape")
			.generate(**kwargs):
				Generate template with the given arguments
		2. class tornado.template.BaseLoader(autoescape='xhtml_escape', namespace=None)
			autoescape must be None or a string naming a function
			.load(name, parent_path=None):
				loads a template
			.reset()
				resets the cache of compiled templates
			.resolve_path(name, parent_path=None):
				converts a possibly-relative path to absolute
		3. class tornado.template.Loader(root_directory, **kwargs)
			A template loader that loads from a single root directory
		4. class tornado.template.DictLoader(dict, **kwargs)
			A template loader that loads from a dictionary
		5. exception tornado.template.ParseError
			raised for template syntax errors
4. tornado.escape
	Escaping:
		tornado.escape.xhtml_escape(value)
			Escapes a string so it is valid within HTML or XMl
		tornado.escape.xhtml_unescape(value)
			Un-escapes an XML-escaped string
		tornado.escape.url_escape(value, plus=True)
			Returns a URL-encoded version of the given value
			If plus is True, spaces will be represented as '+' instead of '%20',
			this is appropriate for query strings but not for the path component of a
			URL. Note that this default is the reverse of Python's urllib module
		tornado.escape.url_unescape(value, encoding='utf-8', plus=True)
			Decodes the given value from a URL
			The argument value may be either a byte or unicode string
			If encoding is None, the result will be a byte string, otherwise, the result
			is a unicode string in the specified encoding
		tornado.escape.json_encode(value)
			JSON-encodes the given Python object
		tornado.escape.json_decode(value)
			Returns Python objects for the given JSON string
	Byte/Unicode convertion:
		tornado.escape.utf8(value)
			Converts a string to a byte string, if the argument is already a byte string
				or None, it is returned unchanged, otherwise it must be a unicode string
				and is encoded as utf8
		tornado.escape.to_unicode(value)
			Converts a string to unicode string, if the argument is already a unicode
				string or None, it is returned unchanged, otherwise it must be a byte
				string and is decoded as utf8
		tornado.escape.native_str(value)
			Converts a byte or unicode string into type str
			Equivalent to utf8 on Python2 and to_unicode on Python3
		tornado.escape.to_basestring(value)
			Converts a string argument to a subclass of basestring
			Look up manual
		tornado.escape.recursive_unicode(obj)
			Walks a simple data structure, converting byte strings to unicode, supports
				list, tuple, dict
	Everything others:
		tornado.escape.linkify(text, shorten=False, extra_params='',
			require_protocol=False, permitted_protocols=['http','https'])
			Converts plain text into HTML link, e.g.
				linkify("Hello http://tornado.org!") would return Hello <a href="http://
				tornado.org">http://tornado.org</a>!
			shorten: long urls will be shortened for display
			extra_params: extra text to include in the link tag, or a callable taking
						  the link as an argument and returning the extra e.g.
						  linkify(text, extra_params='rel="nofollow"class="external"')
						  or
						  def extra_params_cb(url):
						  	if url.startswith('http://example.com'):
						  		return 'class="internal"'
						  	else:
						  		return 'class="external" rel="nofollow"'
						  linkify(text, extra_params=extra_params_cb)
			require_protocol: Only linkify urls which include a protocol can be linkified
			perimitted_protocols: list of protocols which should be linkified, it is
								  very unsafe to include protocols such as 'javascript'
		tornado.escape.squeeze(value)
			replace all sequences of whitespace chars with a single space
5. tornado.locale
	tornado.locale.get(*locale_codes)
		Returns the closet match for the given locale codes
		Iterates over all given locale codes in order, if we have a tight or a loose match
			fot the code(e.g., 'en' fot 'en_US'), we return the locale, otherwise move to
			the next code in the list
		By default we return en_US if no translations are found for any of the specified 
			locales, you can change the default locale with set_default_locale()
	tornado.locale.set_defalut_locale(code)
		The default locale is assumed to be the language used for all strings in the
			system, the translations loaded from disk are mappings from the default locale
			to the destinatioln locale
	tornado.locale.load_translations(directory)
		loads translations from CSV files in a directory
		The translations directory should have translation files of the form, e.g., 
			es_GT.csv. the CSV files should have two or three columns: 
			string, translation, an optional plural indicator. there should be two rows
			in the CSV file for that string, one with plural indicator 'singular' and one
			'plural'
			example csv file:
				"I love you","Te amo"
				"%(name)s liked this","A %(name)s les gusto esto","plural"
				"%(name)s liked this","A %(name)s le gusto esto","singular"
	tornado.locale.load_gettext_translations(directory, domain)
		Loads translations from gettext's locale tree
		Locale tree is similar to system's /usr/share/locale, like:
			{directory}/{lang}/LC_MESSAGES/{domain}.mo
		Three steps are required to have you app translated:
			1. generate POT translation file
				xgettext --language=Python --keyword=_:1,2 -d mydomain file1.py file2.html
			2. merge against existing POT file
				msgmerge old.po mydomain.po > new.po
			3. compile
				msgfmt mydomain.po -o {directroy}/pt_BR/LC_MESSAGES/mydomain.mo
	tornado.locale.get_supported_locales()
		Returns a list of all the supported locale codes
	class tornado.locale.Locale(code, translations)
		Object representing a locale
		After calling one of the load_translations or load_gettext_translations, call
			get or get_closet to get a Locale object
		classmethod get_closet(*locale_codes)
		classmethod get(code)
		.translate(message, plural_message=None, count=None)
			returns the translations fot the given message fot this locale, if plural_
			message is given, you must also provide count, return plural_message when
			count != 1 and return the singular form for the given message when count==1
		.format_date(date, gmt_offset=0,relative=True,shorter=False,full_format=False)
			Formats the given date(which should be GMT)
			by default, we return a relative time(e.g, '2 minutes ago'), you can return
			an absolute date string with relative=False
			you can force a full format date('July 10, 1980') with full_format=True
			This method is primarily intended for dates in the past, for dates in the 
			feature, we fall back to full format
		.format_day(date, gmt_offset=0, dow=True)
			formats the given date as a day of week
		.list(parts)
			returns a comma-separated list for the given list of parts
		.friendly_number(value)
			returns a comma-separated number for the given integer
	class tornado.locale.CSVLocale(code, translations)
		Locale implementation using tornado's CSV translation format
	class tornado.locale.Gettextlocale(code, translations)
		Locale implementation using tthe gettext module
6. tornado.gen
	A generator-based interface to make it easier to work asynchronous networking
	For example, the following asynchronous handler:
		class AsyncHandler(tornado.web.RequestHandler):
			@tornado.web.asynchronous
			def get(self):
				http_client = AsyncHTTPClient()
				http_client.fetch("http://example.com", callback=self.on_fetch)

			def on_fetch(self, response):
				do_something_with_response(response)
				self.render("template.tmpl")
	could be written with tornado.gen as:
		class GenAsyncHandler(tornado.web.RequestHandler):
			@tornado.gen.coroutine
			def get(self):
				http_client = AsycHTTPClient()
				response = yield http_client.fetch("example.com")
				do_something_with_response(response)
				self.render('template.tmpl')
	Most asynchronous functions in Tornado return a Future object, yield this 
		object returns its result
	For functions that don't return Future, Task works with any function that takes
		a callback key argument, e.g.
		@tornado.gen.coroutine
		def get(self):
			yield tornado.gen.Task(AsyncHTTPClient().fetch, "http://example.com")
	You can also yield a list of Futures and/or Tasks, which will be started at the
		same time and run in parallel, a list of results will be returned when they are
		all finished, e.g.
		@tornado.gen.coroutine
		def get(self):
			http_client = AsyncHTTPClient()
			response1, response2 = yield [http_client.fetch(url1),http_client.fetch(url2)]
	1. tornado.gen.coroutine(method)
		decorator for asynchronous generators
		functions with this decorator return a Future object, they may be called with a
		callback keyword argument, which will be invoked with the future's result when
		it resolves, if the coroutine fails, the callback will not be run and an exception
		will be raised into the surrounding StackContext, the callback argument is not
		visible inside the decorated function, it is handled by the decorator itself
	2. tornado.gen.engine(method)
		combination of @return_future and @gen.coroutine is similar to @gen.coroutine
		the coroutine is recommended instead
	3. class tornado.gen.Task(func, *args, **kwargs)
		takes a function and runs it with those arguments plus a callback keyword argument
		, the argument passed to the callback is returned as the result of the yield
		expression, e.g.
			result = yield tornado.gen.Task(func, args)
		is requivalent to a Callback/Wait pair(with a unique key)
			func(args, callback=(yield gen.Callback(key)))
			result = yield gen.Wait(key)
	4. class tornado.gen.Callback(key)
		returns a callable object that will allow a matching Wait to proceed
	5. class tornado.gen.Wait(key)
		returns the argument passed to the result of a previouse Callback
	6. class tornado.gen.WaitAll(keys)
		returns the results of the multiple previous Callbacks
		the argument is a sequence of Callback keys, and the result is a list of results
		in the same order, WaitAll is equivalent ot yielding a list of Wait objects
	7. class tornado.gen.YieldPoint
		Base class for objects that may be yielded fromt the generator
		Applications do not normally need to use this class, but it may be subclassed to
		provide additional yielding behavior
	8. exception tornado.gen.Return(value=None)
		Special exception to return a value from a coroutine, if exception is raised, its
		value argument is used as the result of the coroutine, e.g.
			@tornado.gen.coroutine
			def fetch_json(url):
				response = yield AsnycHTTPClient().fetch(url)
				raise tornado.gen.Return(json_encode(response.body))
	9. class tornado.gen.Arguments
		the result of a yield expression whose callback had more than one argument
7. tornado.ioloop
	1. class tornado.ioloop.IOLoop
		static IOLoop.current()
			returns the current thread's IOLoop
		IOLoop.make_current()
			makes this the IOLoop for the current thread
		static IOLoop.instance()
			returns a global IOLoop instance
		static IOLoop.initialized()
			returns true if the singleton instance has been created
		IOLoop.install()
			installs this IOLoop object as the singleton instance
		IOLoop.start()
			starts the I/O loop
		IOLoop.stop()
			stop the I/O loop
		IOLoop.run_sync(func, timeout=None)
			starts the IOLoop, runs the given function, and stops the loop
		IOLoop.close(all_fds=False)
			closes the IOLoop, freeing any resources used
		IOLoop.add_handler(fd, handler, events)
			registers the given handler to receive the given events for fd
		IOLoop.update_handler(fd, events)
		IOLoop.remove_handler(fd)
		IOLoop.add_callback(callback, *args, **kwargs)
		IOLoop.add_callback_from_signal(callback, *args, **kwargs)
		IOLoop.add_future(future, callback)
		IOLoop.add_timeout(deadline, callback)
		IOLoop.remove_timeout(timeout)
		IOLoop.time()
8. tornado.iostream
	1. class tornado.iostream.BaseIOStream(io_loop=None, max_buffer_size=None,read_chunk_size=4096)
		a utility class to write to and read from a non-blocking socket or file
		support a non-blocking write() and a family of read_*() methods, all of methods
			take callbacks
		when a stream is closed due to an error, the IOStream's error attribute contains
			the exception object
		subclass must implement fileno(), close_fd(), write_to_fd(), read_from_fd() and
			optionally get_fd_error()
		.write(data, callback=None):
			write the given data to this stream
		.read_bytes(num_bytes, callback, streaming_callback=None)
			run callback when we read the given number of bytes, if streaming_callback
			is given, it will be called with chunks of data as they become avaliable,
			and the argument to the final callback will be empty
		.read_until_regex(regex, callback)
			run callback when we read the given regex pattern
		.read_until_close(callback, streaming_callback=None)
			reads all data from the socket until it is closed
		.close(exc_info=False)
			close this stream
		.set_close_callback(callback)
			call the given callback when the stream is closed
		.closed()
			return true if the stream has been closed
		.reading()
			returns true if we are currently reading from the stream
		.writing()
			returns true if we are currently writing to the stream
		.set_nodelay(value)
			set the no-delay flag for this stream
			by default, data written to TCP streams may be held for a time to make the
			most efficient use of bandwidth, the no-delay flag requests that data be
			written as soon as possible
		.fineno()
			returns the file descriptor for this stream
		.close_fd()
			closes the file underlying this stream
		.write_to_fd(data)
			attempts to write data to the underlying file
		.read_from_fd()
			attempts to read data from the underlying file
		.get_fd_error()
			returns information about any error on the underlying file
	2. class tornado.iostream.IOStream(socket, *args, **kwargs)
		socket-based IOStream implemention
		this class supports the read and write methods fromm BaseIOStream plus a
			connect() method
		server operations the socket is the result of calling socket.accept()
		client operations the socket is creaded with socket.socket()
		simple HTTP client:
			import tornado.ioloop
			import tornado.iostream
			import socket

			def send_request():
				stream.write(b"GET / HTTP/1.0\r\nHost: friendfeed.com\r\n\r\n")
				stream.read_until(b"\r\n\r\n", on_headers)
			def on_headers(data):
				headers = {}
				for line in data.split(b"\r\n"):
					parts = line.split(b":")
					if len(parts) == 2:
						headers[parts[0].strip()] = parts[1].strip()
				stream.read_bytes(int(headers[b"Content-Lenght"]), on_body)
			def on_body(data):
				print(data)
				stream.close()
				tornado.ioloop.IOLoop.instance().stop()

			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
			stream = tornado.iostream.IOStream(s)
			stream.connection(("friendfeed.com", 80), send_request)
			tornado.ioloop.IOLoop.instance().start()
		.connection(address, callback=None, server_hostname=None)
			connects the socket to a remote address without blocking
	3. class tornado.iostream.SSLIOStream(*args, **kwargs)
		a untility class to write to and read from a non-blocking SSL socket
	4. class tornado.iostream.PipeIOStream(fd, *args, **kwargs)
		pipe-based IOStream implemention
	5. exception tornado.iostream.StreamCloseError
9. tornado.httpclient
	blocking and non-blocking