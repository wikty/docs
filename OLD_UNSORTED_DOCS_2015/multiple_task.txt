多任务系统是什么？
	对于用户而言就是在同一时刻有若干程序在运行，比如一边听音乐一边编辑文档，
	对于系统（和程序员）而言就是在同一时刻有若干进程/线程运行
	注：上面同一时刻的意思是相对于用户个人感觉来说的，对于计算机来说，是否
		能够在同一时刻运行多个任务与计算机是否拥有多CPU相关，拥有多CPU只是
		在硬件层面加快了系统运行速度，程序员对多进程/线程的使用并不会受到底
		层CPU个数的影响

为什么要使用多任务？
	显然如果你的系统是单任务的，那么当你听歌时，你是不能浏览网页的，直到你关
	掉听歌的程序，即在用户感知的层面系统在任意时刻仅能运行一个程序，进一步来
	讲听歌软件显然具有联网下载音乐和播放音乐两个功能，如果听歌软件将这两个功
	能分别用不同的进程实现的话，在歌曲下载时你是不能听歌的，同样在听歌时你也
	不能下载歌曲，既浪费带宽又是差劲的用户体验，但如果两个功能在一个进程中实
	现，这将会导致软件设计的复杂度上升，所以无论从用户体验的角度还是从软件设
	计的角度来说多任务系统都具有极大的优势

多任务在系统中的表示形式
	通常可认为多任务以进程或线程形式存在，其实在进程之上还有进程组的概念由于
	表示job，job之上还有session的概念，例如当你打开shell时，你已经开始了一个
	session，在该session中你可以启动httpd的job在后台运行，与此同时httpd服务
	又由若干的进程组成，最终每个进程可能会对应若干线程，所以任务只是用于概念
	的描述层次的术语，至于最终任务的实现看具体情况。

进程和线程
	在没有引入线程的操作系统中进程是基本的系统资源分配单位和基本的调度单位，
	在引入线程的操作系统中进程依然是系统资源分配的基本单位，但是基本的调度单
	位，每个进程至少有一个线程，线程共享进程的内存空间，因为线程切换开销较小
	（线程几乎不占用系统资源，并且线程关联寄存器较少），所以多线程的并发性更
	好，但是由于多线程共享进程的内存空间（当然线程在其中有自己的私有空间）以
	及其他进程资源所以多线程访问共享资源需要有机制确保不会相互影响，当前操作
	系统中用于共享资源访问控制的机制有：互斥锁mutex，信号量semaphore（其实互
	斥锁是信号量的值为1时的情况）。

并发多任务的相关术语
	临界资源，一次只允许一个进程访问的资源
	临界区，访问临界资源的相应代码段
	互斥，保证资源成为临界资源的机制
	同步，使得存在逻辑先后顺序的进程在执行时序上保持相同的顺序
	死锁，进程间相互等待正在被对方使用的资源而使得进程处于永久等待的状态
	饥饿，某进程一直占用共享资源使得想要使用该资源的进程处于长期等待的状态
	进程组，与某job相关联的一组进程，该组的每个进程具有统一的组id
	会话，由相关的一组job组成

死锁
	描述：当两个以上进程因争夺资源而出现相互永久等待的现象
	案例：数据库系统中多事务间等待各自正在占用的数据表
	解决方案：首先，通过合适的编程约定避免资源的相互竞争，此外可以通过第三方
		  进程的介入将陷入死锁的某进程终止以允许另一进程的正常运行
	产生条件：
		  1，进程使用的资源具有排他性
		  2，进程独占使用资源，具有不可剥夺性
		  3，进程请求新资源时会阻塞
		  4，进程间相互等待对方在用的独占资源
	预防死锁：
		  有序资源分配算法，银行算法等

中断技术
	描述：在特定事件发生时（产生中断信号），使得CPU暂停正在执行的任务转而去
		  处理为该特定事件编写的处理程序（即中断处理程序），直到处理程序结束
		  后再使CPU恢复之前的执行状态
	作用：
		  1，外设在需要与CPU通信时触发中断，CPU才处理外设相关任务，这样使得
		  	 CPU不必再等待外设了，提供了CPU的利用率
		  2，软硬件故障即时得到处理，因异常而触发中断后CPU就执行相应的中断处
		     程序，使得故障即时得到处理
	分类：根据中断来源不同分为硬中断和软中断
		  硬中断
		  	外部硬件中断，即计算机外设触发的中断，如：键盘，打印机，定时器等
		  		外部中断是可被屏蔽的
		  	内部硬件中断，指因硬件出错（忽然掉电，奇偶校验出错等）或运算出错
		  		（除数为零，运算溢出等），内部中断是不可屏蔽的
		  软中断
		  	*貌似很有用的一项技术，留待以后了解，大概是用软件模式硬中断的实现


实现多任务系统面对的首要问题是什么？
	任务之间的调度切换是首要问题。具体来所就是进程（线程）之间的切换调度，一
	般来说该问题在操作系统级别已经被解决，操作系统提供创建进程（线程）的API，
	应用程序创建任务后操作系统自动负责任务间的切换调度工作，也就是说任务的调
	度对于程序员来说多数情况下是透明的

操作系统是如何实现任务的切换，或者任务切换的本质是什么？
	为了说明的方便，现在假设系统是单CPU的，任何时刻CPU执行哪块内存中存储的代
	码是由CPU中的CS：IP寄存器存储的内存地址决定的，如果改变该寄存器中的地址
	可以使CPU执行别的内存块中的代码了，实际上CPU中除了CS，IP与当前任务相关外
	还有别的寄存器内容与之相关（线程关联的寄存器数量少于进程的），所以进程切
	换的实质就是更换CPU中某些寄存器的内容（CS：IP的值一定改变），具体来讲就是
	将当前寄存器中的内容复制到进程的堆栈中，这样在进程被激活时即可恢复到被切
	换时的状态了，至于触发切发生的机制就是中断技术来实现的


实现多任务系统还要面对哪些问题？
	因为多任务之间可能会存在各种关系，为了处理多任务之间的关系操作系统提供
	了各种机制来解决这些问题。
	（下面以进程来取代任务进行说明，也许线程间的关系和进程间的关系略有不同）
	进程间通信
		目的：
			1，数据传输
				一个进程将数据发送给另外一个进程
			2，数据共享（广播）
				任何进程对共享数据的修改，对其他进程可见
			3，事件通知
				一个进程将某事件告知另一进程
			4，控制进程
				一个进程控制另一个进程
		实现方案：
			管道，包括普通管道，流管道，命名管道三种实现
				  普通管道：单工模式且只能用于父子或兄弟进程之间
				  流管道：半双工模式且只能用于父子或兄弟进程之间
				  命名管道：半双工模式且能用于任意进程间的通信
			系统IPC，即Inter-Process Communication，具体的实现有消息队列，信
				号，共享内存三种
				消息队列，适合生产者-消费者的进程通信模型
				信号，实现了进程之间高效的事件通知机制在，Linux中信号的种类
					  和数目与硬件平台有关。内核用一个字代表所有的信号，每个
					  信号占一位，因此一个字的位数就是系统可以支持的最多信号
					  种类数，kill -l 列出可用所有信号（注：该机制对于对于复
					  杂的交互操作却难以胜任）
				共享内存，适用于进程之间数据共享（广播），但Linux本身不提供
					  对共享内存的互斥访问机制，需要程序员自己确保互斥访问
			套接字，提供了以套接字API的方式实现进程通信
	进程间资源竞争
		目的：
			使得多个进程访问相同的资源和各自独立访问没有任何的差别（即虽然进
			程的执行时间受到影响，但是执行结果不受影响）
		实现方案：
			互斥机制，保证任何时刻只有一个线程访问被共享的资源，即实现共享资
			源的排他使用）
		带来的问题：
			死锁，如果双方进程都等待正在被对方使用的资源就会发生死锁，这两个
			进程就会一直处于无限等待的状态了
			饥饿，如果一个进程一直在占用共享资源，那么要使用该资源的其他进程
			就会饥饿，后者会一直处于等待状态直到资源可用

多线程要解决的若干问题（这里的机制也许同样适用于进程）
	线程同步，使得若干线程按照特定的顺序执行
	线程互斥，不同线程访问同一临界资源
	操作系统提供的机制：
		critical section，使用临界区互斥访问资源
		mutex，既可以用来线程同步也可用来线程互斥
		semaphore，限制访问共享资源的并发数
		event，线程阻塞直到它等待的事件发生
		pv原语，进行semaphore的操作原语（semaphore由操作系统维护），p原语用
			于获取semaphore，若没有可用的信号量线程阻塞，v原语用于释放信号量
			如果有的线程正在阻塞等待就将其唤醒

